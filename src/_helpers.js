// ======================================================
// General
// ======================================================

/**
 * Generates a string based on a string template and a list
 * of arguments.
 *
 * Ex:
 *
 * // Code
 * formatString("$1 $2!", "Hello", "world");
 *
 * // Output
 * "Hello world!"
 *
 * @param {string} template String template.
 */
var formatString = function(template) {
  var output = template + "";
  for (var i = 1; i < arguments.length; i++) {
    output = output.replace("$" + i, arguments[i]);
  }
  return output;
};

/**
 * Executes and returns the value of the received function.
 * @param {function} fn Function to execute.
 * @param {[]} args Function's arguments.
 */
var run = (fn, args) => fn.apply(null, args);

// ======================================================
// Assertions
// ======================================================

/**
 * Checks if the received object is defined in the global
 * scope.
 * @param {*} obj Javascript Object.
 */
var exists = obj => typeof obj !== "undefined";

/**
 * Checks if the received object is of the expected type.
 * @param {*} obj Javascript Object.
 * @param {string} expected Expected type.
 */
var isType = (obj, expected) => exists(obj) && typeof obj === expected;

/**
 * Checks if the received object is equal to the expected
 * value. (Optional) A 3rd parameter is available in case
 * there is a need to use some custom validations.
 * @param {*} obj Javascript Object.
 * @param {*} expected Expected value.
 * @param {function} fn (Optional) Custom validation function.
 */
var isEqual = (obj, expected, fn) => {
  if (!exists(obj) || !exists(expected)) return false;
  return exists(fn) ? fn(obj, expected) : obj === expected;
};

// ======================================================
// Factories
// ======================================================

/**
 *
 * @param {function | boolean} expr Javascript expression.
 * @param {number} score TODO.
 * @param {*} err Error object.
 * @returns {{ type: "ASSERT", isValid: boolean, score: number, err: object }}
 */
var createAssertion = (expr, score, err) => () => {
  // Check if the argument <expr> is valid.
  var isValid = null;
  if (typeof expr === "function") {
    isValid = expr();
  } else if (typeof expr === "boolean") {
    isValid = expr;
  } else {
    throw Error(
      `createAssertion : The type of the first argument <expr> must be of type 'function' or 'boolean'. The actual type is '${typeof expr}'`
    );
  }

  // Check if the argument <score> is valid.
  if (
    typeof score === "undefined" ||
    isNaN(score) ||
    (!isNaN(score) && score < 0)
  ) {
    throw new Error(
      "createAssertion : The second argument <score> is missing or is 'NaN' or is a negative number."
    );
  }

  // Check if the argument <err> is valid.
  if (
    typeof err === "undefined" ||
    typeof err !== "object" ||
    (typeof err === "object" && err.type !== "ASSERTION_ERROR")
  ) {
    throw new Error(
      "createAssertion : The third argument <err> is missing or/and it must be generated by using the 'createAssertError' helper function."
    );
  }

  // Return Assert
  return {
    type: "ASSERTION",
    isValid,
    score,
    err
  };
};

// ------------------------------------------------------

var ASSERT_ERROR_TYPES = {
  TYPE_ERROR: 0
};

/**
 *
 * @param {number} type Error type.
 * @returns {{ type: "ASSERTION_ERROR", msg: string }} Assertion error object.
 */
var createAssertionError = function(type) {
  var args = Array.prototype.slice.call(arguments).slice(1);
  return {
    type: "ASSERTION_ERROR",
    msg: (() => {
      switch (type) {
        case ASSERT_ERROR_TYPES.TYPE_ERROR:
          return ``;
        default:
          return `ERROR_NOT_YET_IMPLEMENTED : type(${type})`;
      }
    })()
  };
};

// ------------------------------------------------------

/**
 *
 * @param {string} name The object of the test.
 * @param {[{ type: "ASSERT" }]} assertions Array of assertions.
 * @return {string} Results of the test.
 */
var createTest = (name, assertions) => () => {
  var failedAssertions = assertions
    .filter(obj => typeof obj === "function")
    .map(fn => fn())
    .filter(a => a.type === "ASSERTION" && !a.isValid);

  return `
Testing : ${name}
===============================\n
${
    failedAssertions.length > 0
      ? failedAssertions.map(a => `${a.err.msg} | (-${a.score})`)
      : "All Good!"
  }`;
};
